# 嵌入式系统原理与应用实验报告

专业班级：计2307班                                 
组员：许洋帆（235150732）姚志昊（235150734）

实验日期：2025年11月4日

## 实验二：外部中断实验---开关优化


#### 一、实验目的

1. 掌握STM32的中断控制器和外部中断的工作原理
2. 学会使用相关工具配置中断以及使用HAL库处理中断的编程方法
3. 掌握使用HAL库读取输出引脚的状态



#### 二、实验内容

		1.	STM32CubeMX中配置外部中断
		2.	HAL库工程解析
		3. 	实验要求体现
		        ( 1 )在按键中断回调函数中加入读取红灯的状态的语句，翻转红灯的状态，即原来是灯的变灭，灭的变亮(注:不能使用HAL GPIO TogglePin函数）
			( 2 )另建一个工程，修改代码，不使用中断的方式，直接读取按键引脚状态，然后改变绿灯的状态。对比本实验中三种改变灯状态的实现方式。




#### 三、实验过程

1. 电路图及说明
  
![a00fe61490492b6dc82275a52c7d626b](https://github.com/user-attachments/assets/99591437-3f70-4767-a331-4949cdfecac2)


　　说明：一个低电平有效的按键输入电路，按键按下时引脚被拉低，STM32通过外部中断或轮询方式检测这个变化，从而控制LED灯状态，完成实验目标。



#### 四、编程

1. 程序流程图

<img width="336" height="835" alt="image" src="https://github.com/user-attachments/assets/94a64b0f-2261-4a6d-b3e3-f9f075252f01" />



2. 主要代码段及解释

  
 初始化代码解释在注释里
 
   ```c
 static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
/* USER CODE BEGIN MX_GPIO_Init_1 */
/* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
 /* 使能GPIO端口时钟，开启对应时钟 */
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  /* 初始化LED引脚电平，设为低电平 */
  HAL_GPIO_WritePin(GPIOB, LD1_Pin|LD3_Pin|LD2_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin : Button_Pin */
/* 配置按键引脚：上升沿触发的外部中断模式 */
  GPIO_InitStruct.Pin = Button_Pin;
/* 中断模式，上升沿触发（按键按下） */
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(Button_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pins : LD1_Pin LD3_Pin LD2_Pin */
 /* 配置LED引脚：推挽输出模式 */
  GPIO_InitStruct.Pin = LD1_Pin|LD3_Pin|LD2_Pin;  
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
/* 低速模式/
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

  /* EXTI interrupt init*/
主优先级3，子优先级0（引脚10-15共享此中断） */
  HAL_NVIC_SetPriority(EXTI15_10_IRQn, 3, 0);
/* 使能外部中断线10-15 */
  HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);

/* USER CODE BEGIN MX_GPIO_Init_2 */
/* USER CODE END MX_GPIO_Init_2 */
}
   ```

   功能实现部分代码解释在注释当中：

 ( 1 )在按键中断回调函数中加入读取红灯的状态的语句，翻转红灯的状态，即原来是灯的变灭，灭的变亮(注:不能使用HAL GPIO TogglePin函数）

   ```c

void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)

{
    
{ 
    /*定义一个变量存储读取的引脚电平值*/
    uint8_t ledState = HAL_GPIO_ReadPin(GPIOB, LD3_Pin);
   /*判断是否为高电平*/
    if (ledState == GPIO_PIN_SET)
	/*是亮的就关了*/
        HAL_GPIO_WritePin(GPIOB, LD3_Pin, GPIO_PIN_RESET);
	/*如果是灭的就让他亮起来*/
    else
        HAL_GPIO_WritePin(GPIOB, LD3_Pin, GPIO_PIN_SET);
}
/* USER CODE END HAL_GPIO_EXTI_Callback 0 */
						}
/* USER CODE END 4 *//* USER CODE BEGIN 4 */

   ```

功能实现部分代码解释在注释当中：
( 2 )另建一个工程，修改代码，不使用中断的方式，直接读取按键引脚状态，然后改变绿灯的状态。对比本实验中三种改变灯状态的实现方式。



   ```c
/* USER CODE BEGIN 4 */
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)

{
    
	
	
	
			/*检查按键状态*/
			
			if (HAL_GPIO_ReadPin(Button_GPIO_Port, Button_Pin) == GPIO_PIN_SET)
			
			{
				uint8_t ledState = HAL_GPIO_ReadPin(GPIOB, LD1_Pin);/*读取当前状态*/

				/*状态翻转*/
				if (ledState == GPIO_PIN_SET)
					{
                   			 HAL_GPIO_WritePin(GPIOB, LD1_Pin, GPIO_PIN_RESET); 
                }
               			 else
                {
                   			 HAL_GPIO_WritePin(GPIOB, LD1_Pin, GPIO_PIN_SET); 
                }
							}
					
	
   
    /* USER CODE END HAL_GPIO_EXTI_Callback 0 */
						}
/* USER CODE END 4 */



   ```





#### 五、实验小结
通过本次实验，我们真正理解了 STM32 外部中断的“硬件-库函数-用户代码”三级关系：
硬件检测到 PC13 上升沿 → NVIC 进入 EXTI15_10_IRQHandler → HAL 框架自动调用 HAL_GPIO_EXTI_Callback() → 用户仅需在回调里完成灯翻转。
相比轮询，中断把 CPU 从“死等按键”中解放出来，功耗与实时性优势明显。




